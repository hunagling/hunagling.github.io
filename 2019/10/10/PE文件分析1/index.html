<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>2019-10-10 PE文件分析及控制台分析工具编写(一) | Cyberh</title><meta name="description" content="2019-10-10 PE文件分析及控制台分析工具编写(一)"><meta name="keywords" content="reverse,C++,windows"><meta name="author" content="z2o_Cyberh"><meta name="copyright" content="z2o_Cyberh"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/10/10/PE文件分析1/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="2019-10-10 PE文件分析及控制台分析工具编写(一)"><meta name="twitter:description" content="2019-10-10 PE文件分析及控制台分析工具编写(一)"><meta name="twitter:image" content="https://user-images.githubusercontent.com/30653530/63736234-003acc80-c8b5-11e9-8048-04b40be60a01.png"><meta property="og:type" content="article"><meta property="og:title" content="2019-10-10 PE文件分析及控制台分析工具编写(一)"><meta property="og:url" content="http://yoursite.com/2019/10/10/PE文件分析1/"><meta property="og:site_name" content="Cyberh"><meta property="og:description" content="2019-10-10 PE文件分析及控制台分析工具编写(一)"><meta property="og:image" content="https://user-images.githubusercontent.com/30653530/63736234-003acc80-c8b5-11e9-8048-04b40be60a01.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="next" title="2019-9-9 反调试保持堆栈平衡" href="http://yoursite.com/2019/09/09/反调试/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://hunagling.github.io/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">Cyberh</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="https://user-images.githubusercontent.com/30653530/63736234-003acc80-c8b5-11e9-8048-04b40be60a01.png" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description"></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title"><div class="posttitle">2019-10-10 PE文件分析及控制台分析工具编写(一)</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-10-10<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-10-10</time></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p><strong>0x1基础知识了解</strong><br>PE：是Windows的可执行文件的格式。Windows中的 exe文件、dll文件，都是PE格式。<br>ImageBase：文件映射基址（起始地址）<br>RVA：偏移地址<br>VA：虚拟地址（其实就是映射文件的实际地址）</p>
<p>为什么我们每次打开IDA，显示的起始位置在0x401000？<br>原因是前面的0x1000为PE文件的头部，没有与程序功能相关的信息。<br>IDA只会加载各个区段给我们看，但是IDA已经分析过PE头部（Ctrl+S查看内存映射）</p>
<p><strong>0x2 PE文件的前四个结构</strong><br>DOS Header：<br>DOS Stub：<br>PE Header:<br>Section Table:<br>PE文件的第一个字节，即DOS Header的第一个字节，四个结构无缝链接。</p>
<p>1 DOS Header<br>所有 PE文件必须以 DOS MZ Header 结构开始，为提供程序在DOS下执行的环境。使用该结构，DOS就能识别出这是一个可执行文件，要执行的代码在 DOS  Header 之后的 DOS Stub中。<br>2 DOS Stub<br>DOS Stub实际上是一个有效的16位 .EXE 或者.COM 程序，DOS Stub 的功能是调用中断21h的9号功能来显示字符串“This program cannot run in DOS mode”。<br>如果PE格式在DOS中执行，实践上是执行DOS Stub。<br>如图，使用工具显示结构：<br><img alt="enter description here" data-src="https://user-images.githubusercontent.com/30653530/66570517-541d1e80-eba0-11e9-92aa-1edb30b801a6.png" class="lozad"></p>
<p>3 PE Header<br>DOS Stub 的后面是 PE Header，提供PE程序在windows中执行的环境。<br>是PE相关结构 IMAGE_NT_HEADERS 的简称，其中包含了许多PE装载器用到的重要域。<br>4 Section Table<br>PE Header 后面是结构数组 Section Table (节表)。<br>节表的每一个成员代表一个区段，对应每个成员的节的属性、文件偏移量、虚拟偏移量等。<br>如图，使用工具显示结构：<br><img alt="enter description here" data-src="https://user-images.githubusercontent.com/30653530/66570526-597a6900-eba0-11e9-9766-24d41d4b6dcb.png" class="lozad"><br><strong>0x3各个结构的重要字段</strong><br>1 DOS Header的字段：<br>e_magic，被称为魔术数字，它被用于表示一个MS-DOS兼容的文件类型。所有MS-DOS兼容的可执行文件都将这个值设为0x5A4D，表示ASCII字符MZ。<br>e_lfnew，一个4字节的文件偏移量，PE文件头部就是由它定位的，即指向 PE Header 。<br>其他，在mos_dos下面使用。</p>
<p>2 DOS Stub：<br>保存在偏移地址0X40开始的位置；<br>Dos Stub实模式残余程序 ，windows上加载exe不会检测这一部分内容是否完整，可以在此放入任何的残余程序（可以搞点事情，自动狗头。</p>
<p>3 PE Header(以及其包含的两个结构体)<br>实际就是一个 IMAGE_NT_HEADERS 结构。定义如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">      +<span class="number">00</span>h            DWORD 	Signature;                   <span class="comment">//用于装载器判断是否是PE结构#define IMAGE_NT_SIGNATURE  0x00004550  </span></span><br><span class="line">      +<span class="number">04</span>h            IMAGE_FILE_HEADER 	FileHeader; <span class="comment">//大小0x14</span></span><br><span class="line">      +<span class="number">18</span>h            IMAGE_OPTIONAL_HEADER 	OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;</span><br></pre></td></tr></table></figure>

<p>定位：由DOS Header中的成员e_lfanew域定位的， e_lfanew给出结构_IMAGE_NT_HEADERS保存位置偏移量。  </p>
<p>PE Header包含的两个结构体:<br>①IMAGE_FILE_HEADER          FileHeader;</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">               WORD 	Machine;<span class="comment">//     该文件运行所要求的CPU。对于Intel平台，该值是IMAGE_FILE_MACHINE_I386 (14Ch)        </span></span><br><span class="line">               WORD 	NumberOfSections;<span class="comment">//section table数组中有效的成员个数。增加或删除一个区段，就需要修改这个值。</span></span><br><span class="line">               DWORD 	TimeDateStamp;<span class="comment">//文件创建日期和时间。</span></span><br><span class="line">               DWORD 	PointerToSymbolTable;<span class="comment">//COFF 符号表格的偏移位置</span></span><br><span class="line">               DWORD 	NumberOfSymbols;</span><br><span class="line">               WORD 	SizeOfOptionalHeader;<span class="comment">//Optional Header结构大小。obj文件为0，exe文件为00e0h。</span></span><br><span class="line">               WORD 	Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>②IMAGE_OPTIONAL_HEADER     OptionalHeader;（比较大</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER</span> &#123;</span></span><br><span class="line"><span class="comment">//标准域</span></span><br><span class="line">                    USHORT Magic;</span><br><span class="line">                    UCHAR 	MajorLinkerVersion;</span><br><span class="line">                    UCHAR 	MinorLinkerVersion;</span><br><span class="line">                    ULONG 	SizeOfCode;</span><br><span class="line">                    ULONG 	SizeOfInitializedData;</span><br><span class="line">                    ULONG 	SizeOfUninitializedData;</span><br><span class="line">                    ULONG 	AddressOfEntryPoint;</span><br><span class="line">                    ULONG 	BaseOfCode;</span><br><span class="line">                    ULONG 	BaseOfData;</span><br><span class="line">                    ULONG  ImageBase;</span><br><span class="line">                    ULONG  SectionAlignment;</span><br><span class="line">                    ULONG  FileAlignment;</span><br><span class="line">                    USHORT  MajorOperatingSystemVersion;</span><br><span class="line">                    USHORT  MinorOperatingSystemVersion;</span><br><span class="line">                    USHORT  MajorImageVersion;</span><br><span class="line">                    USHORT  MinorImageVersion;</span><br><span class="line">                    USHORT  MajorSubsystemVersion;</span><br><span class="line">                    USHORT  MinorSubsystemVersion;</span><br><span class="line">                    ULONG  Reserved1;</span><br><span class="line">                    ULONG  SizeOfImage;</span><br><span class="line">                    ULONG  SizeOfHeaders;</span><br><span class="line">                    ULONG  CheckSum;</span><br><span class="line">                    USHORT  Subsystem;</span><br><span class="line">                    USHORT  DllCharacteristics;</span><br><span class="line">                    ULONG  SizeOfStackReserve;</span><br><span class="line">                    ULONG  SizeOfStackCommit;</span><br><span class="line">                    ULONG  SizeOfHeapReserve;</span><br><span class="line">                    ULONG  SizeOfHeapCommit;</span><br><span class="line">                    ULONG  LoaderFlags;</span><br><span class="line">                    ULONG  NumberOfRvaAndSizes;</span><br><span class="line">                    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];</span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER, *PIMAGE_OPTIONAL_HEADER;</span><br></pre></td></tr></table></figure>

<p>重要字段<br>          1.Magic：image文件类型，取值可以为：<br>              0x010B(IMAGE_NT_OPTIONAL_HDR32_MAGIC)： win32中EXE image<br>              0x020B(IMAGE_NT_OPTIONAL_HDR64_MAGIC)： win64中EXE image<br>          2.MajorLinkerVersion/MinorLinkerVersion：产生此PE文件的链接器的主/次版本号。<br>          3.SizeOfCode：所有code section 的总和大小。<br>              大部分程序只有一个 code section，所以此域通常就是 .text section 的大小。通常是200H的整数倍，即磁盘扇区的字节数。<br>          4.AddressOfEntryPoint：PE文件开始执行的位置。RVA，通常指向 .text section，称程序的入口点。（俗称OEP，很重要脱壳相关<br>          5.ImageBase：映射基地址，PE文件的优先装载基地址(Base Address)。<br>              如果该值是400000h，PE装载器将尝试把文件装到虚拟地址空间的400000h处。若该地址区域已被其他模块占用，那PE装载器会选用其他空闲地址。<br>              涉及基址重定位，一般Exe文件不需要，而Dll文件需要。<br>          6.SectionAlignment：内存中节对齐的粒度.pe文件被映射到内存中，每个section映射的起始地址为该数值整数倍。<br>          7.FileAlignment：文件中节对齐的粒度，pe文件保存在磁盘空间中，每个section保存的磁盘起始地址为该数值整数倍<br>          8.SizeOfImage：整个PE文件映像体的尺寸。<br>          9.DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]： IMAGE_DATA_DIRECTORY 结构数组，即数据目录表。<br>          10.每项给出一个PE中重要数据结构的RVA和大小</p>
<p>4 Section Table</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">BYTE    		Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">                    DWORD   	PhysicalAddress;</span><br><span class="line">                    DWORD   	VirtualSize;</span><br><span class="line">&#125; Misc;</span><br><span class="line">                    DWORD   		VirtualAddress;</span><br><span class="line">                    DWORD   		SizeOfRawData;</span><br><span class="line">                    DWORD   		PointerToRawData;</span><br><span class="line">                    DWORD   		PointerToRelocations;</span><br><span class="line">                    DWORD   		PointerToLinenumbers;</span><br><span class="line">                    WORD    		NumberOfRelocations;</span><br><span class="line">                    WORD    		NumberOfLinenumbers;</span><br><span class="line">                    DWORD   		Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>重要字段<br>          1.NAME数组：不超过8字节的section name，一般第一个为点号。.TEXT, .DATA<br>          2.Misc：一个union，取值可以是physicaladdress（物理地址）或virtualsize(section在内存中的真实大小)。<br>          3.VirtualAddress：本section保存的RVA地址。<br>          4.SizeOfRawData：经过对齐处理后本节在磁盘中的大小(文件大小)，PE装载器根据该值为这个section分配虚拟空间。<br>               假设磁盘上的对齐粒度是0x200，VirtualSize =0x388byte，则sizeofrawdata的值为0x400，本节占用磁盘空间是0x400字节。<br>          5.PointerToRawData：本section的FA地址，PE装载器根据这个值找到节数据在磁盘中的位置。<br>          6.Characteristics：section的属性取值，使用某些2进制取值为1来规定某一属性 r w e</p>
<p><strong>0x4如何检测给定文件是一有效PE文件?</strong><br>1.首先检验文件头部第一个字的值是否等于 IMAGE_DOS_SIGNATURE，是则 DOS MZ Header 有效。<br>2.一旦证明文件的 DOS Header 有效后，使用e_lfanew来定位 PE Header。<br>3.比较 PE Header 的第一个双字的值是否等于 Signature。如果前后两个值都匹配，该文件是一个有效的PE文件。</p>
<p><strong>0x5 C++编写一个简单的PE分析工具</strong><br>代码参考了加密解密第四版，以及一些带佬的文章。<br>这里直接贴出控制台程序代码以及注释。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Commdlg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">OPENFILENAME ofn;</span><br><span class="line"><span class="keyword">char</span> szFile[<span class="number">300</span>];</span><br><span class="line">HANDLE hFile;<span class="comment">//文件句柄</span></span><br><span class="line">HANDLE hMapping;<span class="comment">//映射文件句柄</span></span><br><span class="line">LPVOID ImageBase;<span class="comment">//映像基址</span></span><br><span class="line"><span class="comment">//我是输出函数放到.h头文件当中（可以自己创建一个头文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"******************输入任意字母选择文件**************"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">cin</span> &gt;&gt; a;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"success!!!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	IN DWORD o;</span><br><span class="line">	LPVOID* p;</span><br><span class="line">	ZeroMemory(&amp;ofn, <span class="keyword">sizeof</span>(ofn));</span><br><span class="line">	ofn.lStructSize = <span class="keyword">sizeof</span>(ofn);</span><br><span class="line">	ofn.hwndOwner = <span class="literal">NULL</span>;</span><br><span class="line">	ofn.lpstrFile = (LPWSTR)szFile;</span><br><span class="line">	ofn.lpstrFile[<span class="number">0</span>] = <span class="string">'\0'</span>;</span><br><span class="line">	ofn.nMaxFile = <span class="keyword">sizeof</span>(szFile);</span><br><span class="line">	ofn.lpstrFilter = <span class="string">L"All\0*.*\0Text\0*.TXT\0"</span>;</span><br><span class="line">	ofn.nFilterIndex = <span class="number">1</span>;</span><br><span class="line">	ofn.lpstrFileTitle = <span class="literal">NULL</span>;</span><br><span class="line">	ofn.nMaxFileTitle = <span class="number">0</span>;</span><br><span class="line">	ofn.lpstrInitialDir = <span class="literal">NULL</span>;</span><br><span class="line">	ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST;</span><br><span class="line">	<span class="keyword">if</span> (GetOpenFileName(&amp;ofn))  <span class="comment">//打开文件管理器，选择文件</span></span><br><span class="line">	&#123;</span><br><span class="line">		wprintf(<span class="string">L"%s\n\n"</span>, ofn.lpstrFile);<span class="comment">//打印文件路径</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"user cancelled\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	 </span><br><span class="line">	ConvertLPWSTRToLPSTR(ofn.lpstrFile);</span><br><span class="line">	<span class="keyword">char</span>* path[] = &#123; ConvertLPWSTRToLPSTR(ofn.lpstrFile) &#125;;</span><br><span class="line">	PE(*path);</span><br><span class="line">	showheader();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IsPEFile</span><span class="params">(LPVOID ImageBase)</span><span class="comment">//判断是否为PE</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDH = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtH = <span class="literal">nullptr</span>;</span><br><span class="line">	<span class="keyword">if</span> (!ImageBase)<span class="comment">//判断映像基址</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pDH = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	<span class="keyword">if</span> (pDH-&gt;e_magic != IMAGE_DOS_SIGNATURE)  <span class="comment">//判断是否为"MZ"</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//pDH-&gt;e_lfanew保存PIMAGE_NT_HEADERS32的偏移地址，加上基址pDH即为MAGE_NT_HEADERS的地址</span></span><br><span class="line">	pNtH = (PIMAGE_NT_HEADERS)(pDH + pDH-&gt;e_lfanew );</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showheader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER pDH = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_NT_HEADERS pNtH = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_FILE_HEADER pfile = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_OPTIONAL_HEADER poptional = <span class="literal">nullptr</span>;</span><br><span class="line">	PIMAGE_SECTION_HEADER pSH = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IsPEFile(ImageBase))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"File is not exe \n"</span>);</span><br><span class="line">		<span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">	&#125;</span><br><span class="line">	pDH = (PIMAGE_DOS_HEADER)ImageBase;</span><br><span class="line">	pNtH = (PIMAGE_NT_HEADERS)((DWORD)pDH + pDH-&gt;e_lfanew);</span><br><span class="line">	pfile = (PIMAGE_FILE_HEADER)(&amp;pNtH-&gt;FileHeader);</span><br><span class="line">	poptional = (PIMAGE_OPTIONAL_HEADER)(&amp;pNtH-&gt;OptionalHeader);</span><br><span class="line">	pSH = IMAGE_FIRST_SECTION(pNtH);<span class="comment">//第一个sectionheader</span></span><br><span class="line">	</span><br><span class="line">	printDOS(pDH); <span class="comment">//打印dos header</span></span><br><span class="line">	printNT(pNtH);<span class="comment">//打印signature</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PIMAGE_FILE_HEADER,RVA:%p\n"</span>, pDH-&gt;e_lfanew + <span class="number">0x4</span>);</span><br><span class="line">	printFileHeader(pfile);<span class="comment">//fileheader</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PIMAGE_OPTIONAL_HEADER,RVA:%p\n"</span>, pDH-&gt;e_lfanew + <span class="number">0x18</span>);</span><br><span class="line">	printOPTIONAL_HEADER32(poptional);<span class="comment">//optionalheader</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"pfile-&gt;NumberOfSections=%#x\n"</span>, pfile-&gt;NumberOfSections);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pfile-&gt;NumberOfSections; i++)<span class="comment">//循环输出区段</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"************************_IMAGE_SECTION_HEADER************************\n"</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"PIMAGE_SECTION_HEADER,RVA:%p\n"</span>, (DWORD)pSH-(DWORD)ImageBase);</span><br><span class="line">		printSection(pSH);</span><br><span class="line">		pSH += <span class="number">1</span>;<span class="comment">//type ** 类型的加法 ，规则是：newAdress=address+sizeof(type** -*号)*后的值</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ConvertLPWSTRToLPSTR</span><span class="params">(LPWSTR lpwszStrIn)</span><span class="comment">//转换函数，来源百度转换LPSWSTR为char*</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	LPSTR pszOut = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">try</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (lpwszStrIn != <span class="literal">NULL</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> nInputStrLen = wcslen(lpwszStrIn);</span><br><span class="line">			<span class="comment">// Double NULL Termination  </span></span><br><span class="line">			<span class="keyword">int</span> nOutputStrLen = WideCharToMultiByte(CP_ACP, <span class="number">0</span>, lpwszStrIn, nInputStrLen, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">			pszOut = <span class="keyword">new</span> <span class="keyword">char</span>[nOutputStrLen];</span><br><span class="line">			<span class="keyword">if</span> (pszOut)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">memset</span>(pszOut, <span class="number">0x00</span>, nOutputStrLen);</span><br><span class="line">				WideCharToMultiByte(CP_ACP, <span class="number">0</span>, lpwszStrIn, nInputStrLen, pszOut, nOutputStrLen, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="built_in">std</span>::exception e)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pszOut;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/////////////////////////////////////////////输出函数，参考git上某带佬的输出函数.2333333</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printNT</span><span class="params">(PIMAGE_NT_HEADERS p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"_IMAGE_NT_HEADERS-&gt;Signature=%#x\n"</span>, p-&gt;Signature);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDOS</span><span class="params">(PIMAGE_DOS_HEADER p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PIMAGE_DOS_HEADER,RVA:0x00000000\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"struct _IMAGE_DOS_HEADER &#123;\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD   e_magic=%x\n"</span>, p-&gt;e_magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    LONG   e_lfanew=%#x\n"</span>, p-&gt;e_lfanew);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&#125;\n\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"PIMAGE_NT_HEADERS,RVA:%p\n"</span>, p-&gt;e_lfanew);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printFileHeader</span><span class="params">(PIMAGE_FILE_HEADER p)</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"struct _IMAGE_FILE_HEADER &#123;\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    Machine=%#x\n"</span>, p-&gt;Machine);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    NumberOfSections=%#x\n"</span>, p-&gt;NumberOfSections);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   TimeDateStamp=%#x\n"</span>, p-&gt;TimeDateStamp);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   PointerToSymbolTable=%#x\n"</span>, p-&gt;PointerToSymbolTable);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   NumberOfSymbols=%#x\n"</span>, p-&gt;NumberOfSymbols);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    SizeOfOptionalHeader=%#x\n"</span>, p-&gt;SizeOfOptionalHeader);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    Characteristics=%#x\n"</span>, p-&gt;Characteristics);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&#125;\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOPTIONAL_HEADER32</span><span class="params">(PIMAGE_OPTIONAL_HEADER p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"struct _IMAGE_OPTIONAL_HEADER &#123;\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    Magic=%#x\n"</span>, p-&gt;Magic);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    BYTE    MajorLinkerVersion=%#x\n"</span>, p-&gt;MajorLinkerVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    BYTE    MinorLinkerVersion=%#x\n"</span>, p-&gt;MinorLinkerVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfCode=%#x\n"</span>, p-&gt;SizeOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfInitializedData=%#x\n"</span>, p-&gt;SizeOfInitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfUninitializedData=%#x\n"</span>, p-&gt;SizeOfUninitializedData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   AddressOfEntryPoint=%#x\n"</span>, p-&gt;AddressOfEntryPoint);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   BaseOfCode=%#x\n"</span>, p-&gt;BaseOfCode);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   ImageBase=%#x\n"</span>, p-&gt;ImageBase);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SectionAlignment=%#x\n"</span>, p-&gt;SectionAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   FileAlignment=%#x\n"</span>, p-&gt;FileAlignment);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MajorOperatingSystemVersion=%#x\n"</span>, p-&gt;MajorOperatingSystemVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MinorOperatingSystemVersion=%#x\n"</span>, p-&gt;MinorOperatingSystemVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MajorImageVersion=%#x\n"</span>, p-&gt;MajorImageVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MinorImageVersion=%#x\n"</span>, p-&gt;MinorImageVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MajorSubsystemVersion=%#x\n"</span>, p-&gt;MajorSubsystemVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    MinorSubsystemVersion=%#x\n"</span>, p-&gt;MinorSubsystemVersion);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   Win32VersionValue=%#x\n"</span>, p-&gt;Win32VersionValue);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfImage=%#x\n"</span>, p-&gt;SizeOfImage);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfHeaders=%#x\n"</span>, p-&gt;SizeOfHeaders);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   CheckSum=%#x\n"</span>, p-&gt;CheckSum);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    Subsystem=%#x\n"</span>, p-&gt;Subsystem);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    DllCharacteristics=%#x\n"</span>, p-&gt;DllCharacteristics);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfStackReserve=%#x\n"</span>, p-&gt;SizeOfStackReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfStackCommit=%#x\n"</span>, p-&gt;SizeOfStackCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfHeapReserve=%#x\n"</span>, p-&gt;SizeOfHeapReserve);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfHeapCommit=%#x\n"</span>, p-&gt;SizeOfHeapCommit);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   LoaderFlags=%#x\n"</span>, p-&gt;LoaderFlags);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   NumberOfRvaAndSizes=%#x\n"</span>, p-&gt;NumberOfRvaAndSizes);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&#125;\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSection</span><span class="params">(PIMAGE_SECTION_HEADER p)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"struct _IMAGE_SECTION_HEADER &#123;\n"</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME]=%s\n"</span>, p-&gt;Name);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   PhysicalAddress=%#x\n"</span>, p-&gt;Misc.PhysicalAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   VirtualSize=%#x\n"</span>, p-&gt;Misc.VirtualSize);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   VirtualAddress=%#x\n"</span>, p-&gt;VirtualAddress);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   SizeOfRawData=%#x\n"</span>, p-&gt;SizeOfRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   PointerToRawData=%#x\n"</span>, p-&gt;PointerToRawData);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   PointerToRelocations=%#x\n"</span>, p-&gt;PointerToRelocations);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   PointerToLinenumbers=%#x\n"</span>, p-&gt;PointerToLinenumbers);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    NumberOfRelocations=%#x\n"</span>, p-&gt;NumberOfRelocations);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    WORD    NumberOfLinenumbers=%#x\n"</span>, p-&gt;NumberOfLinenumbers);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"    DWORD   Characteristics=%#x\n"</span>, p-&gt;Characteristics);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"&#125;\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：<br><img alt="enter description here" data-src="https://user-images.githubusercontent.com/30653530/66570534-5d0df000-eba0-11e9-9025-ac7d3eb67589.png" class="lozad"><br><img alt="enter description here" data-src="https://user-images.githubusercontent.com/30653530/66570540-5ed7b380-eba0-11e9-87db-b7b76f823b6a.png" class="lozad"></p>
<p>结尾：下一篇分析导入表导出表及各项重要内容</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">z2o_Cyberh</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/10/10/PE文件分析1/">http://yoursite.com/2019/10/10/PE文件分析1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">Cyberh</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/reverse-C-windows/">reverse,C++,windows    </a></div><div class="post_share"><div class="social-share" data-image="https://user-images.githubusercontent.com/30653530/63736234-003acc80-c8b5-11e9-8048-04b40be60a01.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-buttom"><i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/wechat.jpg"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lozad post-qr-code__img" src="/img/alipay.jpg"><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2019/09/09/反调试/"><img class="next_cover lozad" data-src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>2019-9-9 反调试保持堆栈平衡</span></div></a></div></nav></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2019 By z2o_Cyberh</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://hunagling.github.io/">blog</a>!</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="true"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body></html>